<!DOCTYPE html>
<html>
  <head>
    <title>http4s</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

# An HTTP service is just a Kleisli arrow from a streaming request to a streaming response in the option monad transformer applied to an arbitrary effect. What's the problem?

Ross A. Baker â€¢ [`@rossabaker`](https://twitter.com/rossabaker)

???
- notes here
- see https://remarkjs.com/#1

---

## Intro

- 2009: began writing Scala
- 2010: helped start IndyScala meetup
- 2011: lost source code to Scala 2.8 app, still running
- 2012: began writing Scala professionally
- 2013: started http4s project
- 2014-2017: got increasingly functional
- 2018: started writing Scala and Haskell at Formation

---




# HTTP services

```scala
import cats.data.{Kleisli, OptionT}

trait Request[F[_]]
trait Response[F[_]]
type HttpService[F[_]] = Kleisli[OptionT[F, ?], Request[F], Response[F]]
```

---

## Version 0.0.1

```scala
case class Request(
  method: String,
  uri: String,
  body: String,
)
case class Response(
  status: Int, 
  body: String,
)
```

An HTTP service is just a function from a request to a response.

```scala
type HttpService = Request => Response
```

---

## Hello World

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) =>
    Response(200, s"Hello, $name!")
}
```



---

## Hello World

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) =>
    Response(200, s"Hello, $name!")
}
```

### Unit test

```scala
val req = Request("POST", "/hello", "Indy")
```

```scala
scala> assert("Hello, Indy!", helloWorld(req).body)
âœ” Hello, Indy!
```

---

## Hello World

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) =>
    Response(200, s"Hello, $name!")
}
```

### Load test

```scala
scala> loadTest(helloWorld)
ðŸ˜ŽðŸ˜ŽðŸ˜ŽðŸ˜ŽðŸ˜ŽðŸ˜ŽðŸ˜Ž
```

---

## Async backend

```scala
import scala.concurrent._, duration._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    val resp = translate(name).map(Response(200, _))
    Await.result(resp, 3.seconds)
}
val englishToSpanish = svc(Translator(English, Spanish))
```

---

## Async backend

```scala
import scala.concurrent._, duration._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    val resp = translate(name).map(Response(200, _))
    Await.result(resp, 3.seconds)
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### Unit test

```scala
val req = Request("POST", "/translate", "one")
```

```scala
scala> assert("uno", englishToSpanish(req).body)
âœ” uno
```

---

## Async backend

```scala
import scala.concurrent._, duration._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    val resp = translate(name).map(Response(200, _))
    Await.result(resp, 3.seconds)
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### Load test




```scala
scala> loadTest(englishToSpanish)
```

<center>
<img src="https://i.imgflip.com/25pa35.jpg" alt="Await is bad and you should feel bad" style="height: 165px;"/>
</center>

---

## Version 0.0.2

An HTTP service is just a function from a request to a response in a
future.

```scala
type HttpService = Request => Future[Response]
```

---

## Async backend, v0.0.2

```scala
import scala.concurrent._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

---

## Async backend, v0.0.2

```scala
import scala.concurrent._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### Unit test

```scala
val req = Request("POST", "/translate", "one")
```

```scala
scala> asyncAssert("uno", englishToSpanish(req).map(_.body))
âœ” uno
```

---

## Async backend, v0.0.2

```scala
import scala.concurrent._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### Load test




```scala
scala> loadTest(englishToSpanish)
res6: String = âœ¨âœ¨âœ¨ IT'S REACTIVE âœ¨âœ¨âœ¨
```

---

## Async backend, v0.0.2

```scala
import scala.concurrent._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### But we said it was total and gave it a partial

```scala
val req = Request("POST", "/traducir", "one")
```

```scala
scala> asyncAssert("uno", englishToSpanish(req).map(_.body))
scala.MatchError: Request(POST,/traducir,one) (of class Request)
  at .$anonfun$svc$1(<console>:52)
  ... 43 elided
```

---

## Version 0.0.3

An HTTP service is just a partial function from a request to a
response in a future.


```scala
type HttpService = PartialFunction[Request, Future[Response]]

val NotFoundF = Future.successful(Response(404, "ðŸ˜¿"))
```

---

## Async backend, v0.0.3

```scala
import scala.concurrent._
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

---

## Async backend, v0.0.3

```scala
def svc(translate: String => Future[String]): HttpService = {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val englishToSpanish = svc(Translator(English, Spanish))
```

### Unit test

```scala
val good = Request("POST", "/translate", "one")
val bad = Request("POST", "/traducir", "one")
```

```scala
scala> asyncAssert(200, englishToSpanish.applyOrElse(good, 
     |   Function.const(NotFoundF)).map(_.status))
âœ” 200

scala> asyncAssert(404, englishToSpanish.applyOrElse(bad, 
     |   Function.const(NotFoundF)).map(_.status))
âœ” 404
```

---

## Combining services with `orElse`

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) => 
    Future.successful(Response(200, s"Hello, $name!"))
}
val holaMundo: HttpService = {
  case Request("POST", "/hola", name) => 
    Future.successful(Response(200, s"Â¡Hola, $name!"))
}
val monolith: HttpService = helloWorld orElse holaMundo
```

---

## Combining services with `orElse`

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) => 
    Future.successful(Response(200, s"Hello, $name!"))
}
val holaMundo: HttpService = {
  case Request("POST", "/hola", name) => 
    Future.successful(Response(200, s"Â¡Hola, $name!"))
}
val monolith: HttpService = helloWorld orElse holaMundo
```

### Unit test

```scala
import cats.implicits._
val en = Request("POST", "/hello", "Indy")
val es = Request("POST", "/hola",  "Indy")
```

```scala
scala> asyncAssert("Hello, Indy!", monolith.applyOrElse(en, Function.const(NotFoundF)).map(_.body))
âœ” Hello, Indy!

scala> asyncAssert("Â¡Hola, Indy!", monolith.applyOrElse(es, Function.const(NotFoundF)).map(_.body))
âœ” Â¡Hola, Indy!
```

---

## Combining services with `orElse`, v0.0.3

```scala
val helloWorld: HttpService = {
  case Request("POST", "/hello", name) => 
    Future.successful(Response(200, s"Hello, $name!"))
}
val holaMundo: HttpService = {
  case Request("POST", "/hola", name) => 
    Future.successful(Response(200, s"Â¡Hola, $name!"))
}
val monolith: HttpService = helloWorld orElse holaMundo
```

### But we said it was partial and Scala said it was total

```scala
val german = Request("POST", "/hallo", "one")
```

```scala
scala> asyncAssert(404, monolith(german).map(_.status))
scala.MatchError: Request(POST,/hallo,one) (of class Request)
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:254)
  at scala.PartialFunction$$anon$1.apply(PartialFunction.scala:252)
  at $anonfun$1.applyOrElse(<console>:58)
  at $anonfun$1.applyOrElse(<console>:58)
  at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:34)
  at $anonfun$1.applyOrElse(<console>:58)
  at $anonfun$1.applyOrElse(<console>:58)
  at scala.PartialFunction$OrElse.apply(PartialFunction.scala:168)
  ... 43 elided
```

---

## Version 0.0.4

An HTTP service is just a function from a request to a response in an
option of a future.

```scala
type HttpService = Request => Option[Future[Response]]
```

### Sugar

```scala
object HttpService {
  def apply(pf: PartialFunction[Request, Future[Response]]) = pf.lift
}
```

---

## Combining services, v0.0.4

```scala
val helloWorld: HttpService = HttpService {
  case Request("POST", "/hello", name) => 
    Future.successful(Response(200, s"Hello, $name!"))
}
val holaMundo: HttpService = HttpService {
  case Request("POST", "/hola", name) => 
    Future.successful(Response(200, s"Â¡Hola, $name!"))
}
val monolith: HttpService = 
  (Function.unlift(helloWorld) orElse Function.unlift(holaMundo)).lift
```

---

## Combining services, v0.0.4

```scala
val helloWorld: HttpService = HttpService {
  case Request("POST", "/hello", name) => 
    Future.successful(Response(200, s"Hello, $name!"))
}
val holaMundo: HttpService = HttpService {
  case Request("POST", "/hola", name) => 
    Future.successful(Response(200, s"Â¡Hola, $name!"))
}
val monolith: HttpService = 
  (Function.unlift(helloWorld) orElse Function.unlift(holaMundo)).lift
```

### Unit test

```scala
def req(path: String) = Request("POST", path, "Indy")
```

```scala
scala> asyncAssert(200, monolith(req("/hello")).getOrElse(NotFoundF).map(_.status))
âœ” 200

scala> asyncAssert(200, monolith(req("/hola")).getOrElse(NotFoundF).map(_.status))
âœ” 200

scala> asyncAssert(404, monolith(req("/hallo")).getOrElse(NotFoundF).map(_.status))
âœ” 404
```

---

## Async routing

```scala
def imageServer(fetch: String => Future[Option[Image]]) = HttpService {
  case Request("GET", path, _) =>
    fetch(path).map {
      case Some(image) => Response(200, image)
      case None => Response(404, "Image Not Found")
    }
}
val svc = (Function.unlift(imageServer(Cache.fetch))
  orElse Function.unlift(imageServer(Archive.fetch))).lift
```

---

## Image server

```scala
def imageServer(fetch: String => Future[Option[Image]]) = HttpService {
  case Request("GET", path, _) =>
    fetch(path).map {
      case Some(image) => Response(200, image)
      case None => Response(404, "Image Not Found")
    }
}
val svc = (Function.unlift(imageServer(Cache.fetch))
  orElse Function.unlift(imageServer(Archive.fetch))).lift
```

### Unit test

```scala
scala> asyncAssert(false, Cache.fetch("/zoidberg.png").map(_.isDefined))
âœ” false

scala> asyncAssert(true, Archive.fetch("/zoidberg.png").map(_.isDefined))
âœ” true

scala> asyncAssert(200, svc(Request("GET", "/zoidberg.png", "")).getOrElse(NotFoundF).map(_.status))
âŒ Expected: 200
âŒ Actual  : 404
```

---

## Version 0.0.5

An HTTP service is just a function from a request to a response in a
future of an option.

```scala
type HttpService = Request => Future[Option[Response]]
```

### Sugar

```scala
import cats.implicits._
object HttpService {
  def apply(pf: PartialFunction[Request, Future[Response]]): HttpService = 
    pf.lift.andThen(_.sequence)
}
val NotFound = Response(404, "ðŸ˜¿")
```

---

## Image server, v0.0.5

```scala
def imageServer(fetch: String => Future[Option[Image]]): HttpService = {
  case Request("GET", path, _) => fetch(path).map(_.map(Response(200, _)))
  case _ => Future.successful(None)
}
val svc: HttpService = req => imageServer(Cache.fetch)(req).flatMap {
  case some @ Some(resp) => Future.successful(some)
  case None => imageServer(Archive.fetch)(req)
}
```

---

## Image server, v0.0.5

```scala
def imageServer(fetch: String => Future[Option[Image]]): HttpService = {
  case Request("GET", path, _) => fetch(path).map(_.map(Response(200, _)))
  case _ => Future.successful(None)
}
val svc: HttpService = req => imageServer(Cache.fetch)(req).flatMap {
  case some @ Some(resp) => Future.successful(some)
  case None => imageServer(Archive.fetch)(req)
}
```

### Unit test

```scala
scala> asyncAssert(false, Cache.fetch("/zoidberg.png").map(_.isDefined))
âœ” false

scala> asyncAssert(true, Archive.fetch("/zoidberg.png").map(_.isDefined))
âœ” true

scala> asyncAssert(200, svc(Request("GET", "/zoidberg.png", ""))
     |   .map(_.getOrElse(NotFound)).map(_.status))
âœ” 200
```

---

## Version 0.0.6

An HTTP service is just a function from a request to a response in the
option monad transformer applied to Future.

```scala
import cats.data.OptionT
type HttpService = Request => OptionT[Future, Response]
```

### Sugar

```scala
object HttpService {
  def apply(pf: PartialFunction[Request, Future[Response]]): HttpService = 
    pf.lift andThen { optF => OptionT(optF.sequence) }
}
```

---

## Image server, v0.0.6

```scala
def imageServer(fetch: String => OptionT[Future, Image]): HttpService = {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = { req => 
  imageServer(Cache.fetchT)(req) orElse imageServer(Archive.fetchT)(req) }
```

---

## Image server, v0.0.6

```scala
def imageServer(fetch: String => OptionT[Future, Image]): HttpService = {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = { req => 
  imageServer(Cache.fetchT)(req) orElse imageServer(Archive.fetchT)(req) }
```

### Unit test

```scala
scala> asyncAssert(false, Cache.fetchT("/zoidberg.png").isDefined)
âœ” false

scala> asyncAssert(true, Archive.fetchT("/zoidberg.png").isDefined)
âœ” true

scala> asyncAssert(200, svc(Request("GET", "/zoidberg.png", ""))
     |   .fold(404)(_.status))
âœ” 200
```

---

## Version 0.0.7

An HTTP service is just a Kleisli arrow from a request to a response
in the option monad transformer applied to Future.

```scala
import cats.data.{Kleisli, OptionT}
import cats.implicits._
type HttpService = Kleisli[OptionT[Future, ?], Request, Response]
```

---

## Image server, v0.0.7

```scala
def imageServer(fetch: String => OptionT[Future, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.fetchT) <+> imageServer(Archive.fetchT)
```

---

## Image server, v0.0.7

```scala
def imageServer(fetch: String => OptionT[Future, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.fetchT) <+> imageServer(Archive.fetchT)
```

### Unit test

```scala
scala> asyncAssert(false, Cache.fetchT("/zoidberg.png").isDefined)
âœ” false

scala> asyncAssert(true, Archive.fetchT("/zoidberg.png").isDefined)
âœ” true

scala> asyncAssert(200, svc(Request("GET", "/zoidberg.png", "")).fold(404)(_.status))
âœ” 200
```

---

## Image server, v0.0.7, with logging

```scala
def imageServer(fetch: String => OptionT[Future, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.lfetchT) <+> imageServer(Archive.lfetchT)
```

### Oops

```scala
svc(Request("GET", "/zoidberg.png", "")).fold(404)(_.status)
// Found in cache
// Found in archive
// res29: scala.concurrent.Future[Int] = Future(Success(200))
```

![I'm going for a scuttle](http://i.imgur.com/Hu20yUC.gif)

---

## Version 0.0.8

An HTTP service is just a Kleisli arrow from a request to a response
in the option monad transformer applied to IO.

```scala
import cats.data.{Kleisli, OptionT}
import cats.effect.IO
import cats.implicits._
type HttpService = Kleisli[OptionT[IO, ?], Request, Response]
```

---

## Image server, v0.0.8

```scala
def imageServer(fetch: String => OptionT[IO, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.lfetch[IO]) <+> imageServer(Archive.lfetch[IO])
```

---

## Image server, v0.0.8

```scala
def imageServer(fetch: String => OptionT[IO, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.lfetch[IO]) <+> imageServer(Archive.lfetch[IO])
```

```scala
svc(Request("GET", "/zoidberg.png", "")).fold(404)(_.status)
// res30: cats.effect.IO[Int] = <function1>
```

---

## Image server, v0.0.8

```scala
def imageServer(fetch: String => OptionT[IO, Image]): HttpService = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
val svc: HttpService = imageServer(Cache.lfetch[IO]) <+> imageServer(Archive.lfetch[IO])
```

```scala
svc(Request("GET", "/zoidberg.png", "")).fold(404)(_.status).unsafeRunSync
// Found in cache
// res31: Int = 200
```

---
class: center, middle

![Why not Monix?](https://i.imgflip.com/25qxo7.jpg)

---

## Version 0.0.9

An HTTP service is just a Kleisli arrow from a request to a response
in the option monad transformer applied to an arbitrary effect.

```scala
import cats.Applicative, cats.data.{Kleisli, OptionT}, cats.implicits._
type HttpService[F[_]] = Kleisli[OptionT[F, ?], Request, Response]

object HttpService {
  def apply[F[_]: Applicative](pf: PartialFunction[Request, F[Response]]): HttpService[F] =
    Kleisli(pf.lift.andThen(_.sequence).andThen(OptionT.apply))
}
```

---

## Image server, v0.0.9

```scala
import cats.effect.Sync, monix.eval.Task, monix.execution.Scheduler.Implicits.global
def imageServer[F[_]: Sync](fetch: String => OptionT[F, Image]): HttpService[F] = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
def svc[F[_]: Sync] = imageServer[F](Cache.lfetch[F]) <+> imageServer(Archive.lfetch[F])
```

### Bring your own effect

```scala
svc[IO].run(Request("GET", "/zoidberg.png", "")).
  fold(404)(_.status).unsafeRunSync
// Found in cache
// res33: Int = 200

svc[Task].run(Request("GET", "/zoidberg.png", "")).
  fold(404)(_.status).foreach(println)
// Found in cache
// 200
// res34: monix.execution.CancelableFuture[Unit] = monix.execution.CancelableFuture$Pure@32e6ad45
```

---

## Image server, v0.0.9

```scala
import cats.effect.Sync, monix.eval.Task, monix.execution.Scheduler.Implicits.global
def imageServer[F[_]: Sync](fetch: String => OptionT[F, Image]): HttpService[F] = Kleisli {
  case Request("GET", path, _) => fetch(path).map(Response(200, _))
  case _ => OptionT.none
}
def svc[F[_]: Sync] = imageServer[F](Cache.lfetch[F]) <+> imageServer(Archive.lfetch[F])
```

### But not Future 

```scala
scala> svc[Future].run(Request("GET", "/zoidberg.png", "")).fold(404)(_.status)
<console>:83: error: could not find implicit value for evidence parameter of type cats.effect.Sync[scala.concurrent.Future]
       svc[Future].run(Request("GET", "/zoidberg.png", "")).fold(404)(_.status)
          ^
```

---

## Translation, v0.0.9

```scala
def svc[F[_]: Sync](translate: String => F[String]): HttpService[F] = HttpService {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val xlate = svc(Translator.get[IO](English, Spanish))
```

---

## Translation, v0.0.9

```scala
def svc[F[_]: Sync](translate: String => F[String]): HttpService[F] = HttpService {
  case Request("POST", "/translate", name) =>
    translate(name).map(Response(200, _))
}
val xlate = svc(Translator.get[IO](English, Spanish))
```




```scala
scala> xlate.run(Request("POST", "/translate", PaulReveresRide)).fold("")(_.body).unsafeRunSync
res36: String =
"
Escuchen, hijos mÃ­os, y oirÃ¡n
Del paseo de medianoche de Paul Revere,
El dieciocho de abril, en Setenta y cinco:
Apenas un hombre estÃ¡ vivo
Â¿QuiÃ©n recuerda ese famoso dÃ­a y aÃ±o?

Le dijo a su amigo: "Si la marcha britÃ¡nica
Por tierra o mar desde el pueblo esta noche,
Cuelgue una linterna en el arco campanario
De la Torre de la Iglesia del Norte, como una luz de seÃ±al, -
Uno si por tierra, y dos si por mar;
Y yo en la orilla opuesta,
Listo para montar y difundir la alarma
A travÃ©s de cada aldea y granja de Middlesex,
Para que la gente del campo se levante y se arme ".

Luego dijo "Â¡Buenas noches!" Y con el remo amortiguado
En silencio remado a la orilla de Charlestown,
Justo cuando la luna se elevaba sobre la bahÃ­a,
Donde se balanceaba de par e...
```

---

## Version 0.0.10

An HTTP service is just a Kleisli arrow from a streaming request to a
streaming response in the option monad transformer applied to an
arbitrary effect.

```scala
import fs2.Stream
case class Request[F[_]](
  method: String,
  uri: String,
  body: Stream[F, Byte],
)
case class Response[F[_]](
  status: Int, 
  body: Stream[F, Byte],
)
type HttpService[F[_]] = Kleisli[OptionT[F, ?], Request[F], Response[F]]
```




---

## Translation, v0.0.10

```scala
import fs2.{Pipe, Stream}, fs2.text._
def svc[F[_]: Sync](translate: Pipe[F, String, String]): HttpService[F] = 
  HttpService {
    case Request("POST", "/translate", body) =>
      val xlated = translate(body.through(utf8Decode))
        .through(utf8Encode)
      Sync[F].pure(Response(200, xlated))
  }
val xlate = svc(Translator.streaming[IO](English, Spanish))
```

---

## Consume the streaming endpoint, v0.0.10

```scala
scala> (Stream.eval(xlate(Request("POST", "/translate", PaulReveresStream)).value)
     |    .unNoneTerminate          // strip away the option
     |    .flatMap(_.body)          // just the body
     |    .through(utf8Decode)      // bytes to Strings
     |    .take(5)                  // take the first 5
     |    .compile.toList           // Stream[F,String] => F[List[String]]
     |    .map(_.mkString("\n"))    // join lines together
     |    .unsafeRunSync)           // the end of the world
res37: String =
Escuchen, hijos mÃ­os, y oirÃ¡n
Del paseo de medianoche de Paul Revere,
El dieciocho de abril, en Setenta y cinco:
Apenas un hombre estÃ¡ vivo
Â¿QuiÃ©n recuerda ese famoso dÃ­a y aÃ±o?
```

---

## PureConfig

```scala
import pureconfig._, pureconfig.module.catseffect._
// import pureconfig._
// import pureconfig.module.catseffect._

case class DbConf(url: String, username: String, password: String)
// defined class DbConf

val config = loadConfigF[IO, DbConf]
// config: cats.effect.IO[DbConf] = IO$1863330204
```

---

## Doobie

```scala
import doobie._, doobie.implicits._, doobie.h2._
// import doobie._
// import doobie.implicits._
// import doobie.h2._

def xa(conf: DbConf): IO[Transactor[IO]] = 
  H2Transactor.newH2Transactor[IO](conf.url, conf.username, conf.password)
// xa: (conf: DbConf)cats.effect.IO[doobie.Transactor[cats.effect.IO]]

def numbers(xa: Transactor[IO]): Stream[IO, (Int, String)] =
  sql"select id, en from numbers order by id".query[(Int, String)].stream.transact(xa)
// numbers: (xa: doobie.Transactor[cats.effect.IO])fs2.Stream[cats.effect.IO,(Int, String)]
```

---

## jawn-fs2

```scala
import fs2.Chunk
import _root_.io.circe.Json
import _root_.io.circe.jawn.CirceSupportParser.facade
import jawnfs2._
```

```scala
Stream.emit("""{"one":1}\n{"two":2}\n{"three":3}\n""").
  covary[IO].
  through(parseJsonStream[IO, String, Json]).
  evalMap(s => IO(println(s))).
  compile.drain
// res38: cats.effect.IO[Unit] = IO$1213646801
```

---

## A real http4s service

```scala
import io.circe.syntax._
import org.http4s._, org.http4s.circe._

def svc(xa: Transactor[IO]): HttpService[IO] = 
  HttpService[IO] {
    case req =>
      val nums = numbers(xa).map { case (i, n) =>
        Json.obj("int" -> i.asJson, "name" -> n.asJson).asJson
      }
      Response(Status.Ok).withBody(nums)
  }
```

---

## All together now




```scala
def parseResponse(resp: Response[IO]): IO[List[Json]] = {
  resp.body.chunks.parseJsonStream
    .compile.toList
}

val prog = for {
  c      <- config
  xa     <- H2Transactor.newH2Transactor[IO](c.url, c.username, c.password)
  _      <- DoobieExample.setUp(xa)
  server <- BlazeBuilder[IO].mountService(svc(xa)).bindHttp(8080).start
  client <- Http1Client[IO]()
  req    <- GET(uri("http://localhost:8080/"))
  nums   <- client.fetch(req)(resp => parseResponse(resp))
  _      <- client.shutdown
  _      <- server.shutdown
} yield nums
```

```scala
scala> prog.unsafeRunSync()
res41: List[io.circe.Json] =
List({
  "int" : 1,
  "name" : "one"
}, {
  "int" : 2,
  "name" : "two"
}, {
  "int" : 3,
  "name" : "three"
})
```

---
class: center, middle

# Thanks!
Code and slides at `rossabaker/boston-http4s` on GitHub

## Questions?

 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
